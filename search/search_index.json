{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Rhea","text":"<p>A RAG+MCP tool server for Galaxy Toolshed.</p> <p>Example executions with Claude:</p> <ul> <li><code>https://claude.ai/share/37e6cf45-7139-405c-9280-61a469edf81f</code></li> <li><code>https://claude.ai/share/ce922736-ab3a-4e1a-8901-8ca26cfb59cb</code></li> </ul>"},{"location":"#how-it-works","title":"How it works?","text":"<p>The MCP server first provides a single tool, <code>find_tools</code> which accepts a natural language query to select relevant tools. For example, an LLM (or user) can provide a query of \"I need a tool to convert a CSV file to tabular.\", which the server will then perform a RAG on a collection of tools to populate the server with <code>n</code> most relevant tools to the query. Once the server is populated, the LLM/user will have access to those relevant tools, along with their parameter annotations and documentations.</p> <p>To provide file inputs/outputs with the tool agents, we utilize ProxyStore with a Redis backend, providing keys to the tool when a file input is required. </p> <p>When a tool is called, the server utilizes Parsl to spawn an Academy agent that creates an environment for the tool, installing necessary requirements and pulling program files from a S3 object store. The agent will be provided the arguments provided by the MCP server, and return its stdout/stderr along with any output files as ProxyStore keys.</p>"},{"location":"#setup","title":"Setup","text":""},{"location":"#requirements","title":"Requirements","text":"<ul> <li><code>uv</code> - Package manager for Python projects.</li> <li><code>docker</code> - To run tools locally (external executor comming soon!)</li> </ul> <p>Additionally, the server will need to point to an existing OpenAI-like endpoint (for embedding), Postgres, Redis, and MinIO server. Documentation coming soon.</p>"},{"location":"#instalation","title":"Instalation","text":"<p>After cloning the repository, use <code>uv</code> to configure the virtual environment. </p> <pre><code>uv sync\n</code></pre>"},{"location":"#configuring-environment","title":"Configuring Environment","text":"<p>An example <code>.env</code> file is provided in <code>.env.example</code>. Datasets coming soon!</p>"},{"location":"#installing-into-claude-desktop","title":"Installing into Claude Desktop","text":"<p>In your <code>claude_desktop_config.json</code> file, add the following entry (Make sure to replace <code>location_of_repo</code> with the actual location!):</p>"},{"location":"#macoslinux","title":"macOS/Linux","text":"<pre><code>{\n  \"mcpServers\": {\n    \"Rhea\": {\n        \"command\": \"bash\",\n        \"args\": [\n            \"-lc\",\n            \"cd location_of_repo &amp;&amp; uv run -m server.mcp_server\"\n        ]\n    }\n  }\n}\n</code></pre>"},{"location":"#windows-wsl","title":"Windows (WSL)","text":"<pre><code>{\n  \"mcpServers\": {\n    \"Rhea\": {\n        \"command\": \"wsl.exe\",\n        \"args\": [\n            \"bash\",\n            \"-lc\",\n            \"cd location_of_repo &amp;&amp; uv run -m server.mcp_server\"\n        ]\n    }\n  }\n}\n</code></pre>"},{"location":"#testing-with-mcp-inspector","title":"Testing with MCP Inspector","text":"<p>To test the tools with MCP Inspector:</p> <pre><code>npx @modelcontextprotocol/inspector\n</code></pre> <p>And set the following configuration parameters:</p> Parameter Value Transport Type STDIO Command uv Arguments run -m server.mcp_server Request Timeout 600000 Reset Timeouts on Progress True Maximum Total Timeout 600000 Proxy Session Token Token provided within CLI <p>Note: The timeouts are a temporary workaround to make sure the MCP client does not timeout during long tool executions. Better progress reporting is coming soon.</p>"},{"location":"#running-with-sse-transport","title":"Running with SSE Transport","text":"<p>By default, the MCP server will start with STDIO transport for use with Claude Desktop. To enable SSE transport layer:</p> <pre><code>uv run -m server.mcp_server --transport sse\n</code></pre>"},{"location":"#running-with-streamable-http","title":"Running with Streamable HTTP","text":"<p>Work in progress!</p>"},{"location":"client/","title":"Client Python Library","text":"<p>The Rhea client Python library allows you to interact with the Rhea MCP server similar to the FastMCP client library.</p> <p>The client library utilizes both MCP and REST protocols of the Rhea server to allow for MCP tool calling and REST API file handling.</p> <p>See examples on how to use the Client library.</p>"},{"location":"client/#client.RheaClient","title":"<code>RheaClient(hostname, port, secure=False)</code>","text":"<p>               Bases: <code>RheaMCPClientBase</code>, <code>RheaRESTClientBase</code></p> <p>A client class to interact with both the Rhea Model Context Protocol (MCP) server and REST backend.</p> <p>The client class provides similar high-level interface to the one found within the Python MCP SDK.</p> <p>The class also provides additional utilities to interact with the REST backend such as file upload and downloads.</p> <p>Example: <pre><code>async with RheaClient('localhost', 3001) as client:\n    # MCP call\n    tools = await client.find_tools('I need a tool to convert FASTA to FASTQ')\n    # REST call\n    key = await client.upload_file('test.txt')\n</code></pre></p> Source code in <code>client/__init__.py</code> <pre><code>def __init__(self, hostname: str, port: int, secure: bool = False):\n    self._hostname = hostname\n    self._port = port\n    self._secure = secure\n\n    self._mcp_ctx: Optional[RheaMCPClient] = None\n    self._mcp_client: Optional[RheaMCPClient] = None\n\n    self._rest_ctx: Optional[RheaRESTClient] = None\n    self._rest_client: Optional[RheaRESTClient] = None\n</code></pre>"},{"location":"client/#client.RheaClient.list_tools","title":"<code>list_tools()</code>  <code>async</code>","text":"<p>List the currently available tools on the server for this session.</p> <p>Returns:</p> Type Description <code>list[Tool]</code> <p>list[Tool]: A list of MCP tool definitions.</p> Source code in <code>client/__init__.py</code> <pre><code>async def list_tools(self) -&gt; list[Tool]:\n    if self._mcp_client is not None:\n        return await self._mcp_client.list_tools()\n    raise RuntimeError(\"`mcp_client` is None\")\n</code></pre>"},{"location":"client/#client.RheaClient.find_tools","title":"<code>find_tools(query)</code>  <code>async</code>","text":"<p>Find available tools on the MCP server that match the query.</p> <p>This method searches for tools matching the provided query string and returns their descriptions.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query to find relevant tools.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: A list of tool descriptions matching the query.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the client session fails to initialize or used outside of a context manager.</p> Source code in <code>client/__init__.py</code> <pre><code>async def find_tools(self, query: str) -&gt; list[dict]:\n    if self._mcp_client is not None:\n        return await self._mcp_client.find_tools(query)\n    raise RuntimeError(\"`mcp_client` is None\")\n</code></pre>"},{"location":"client/#client.RheaClient.call_tool","title":"<code>call_tool(name, arguments)</code>  <code>async</code>","text":"<p>Call a specific tool on the MCP server with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the tool to call.</p> required <code>arguments</code> <code>dict[str, Any]</code> <p>The arguments to pass to the tool.</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: The structured content of the tool's response,          or None if there is no structured content.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the client session fails to initialize or used outside of a context manager.</p> Source code in <code>client/__init__.py</code> <pre><code>async def call_tool(self, name: str, arguments: dict[str, Any]) -&gt; dict | None:\n    if self._mcp_client is not None:\n        return await self._mcp_client.call_tool(name, arguments)\n    raise RuntimeError(\"`mcp_client` is None\")\n</code></pre>"},{"location":"client/#client.RheaClient.list_resources","title":"<code>list_resources()</code>  <code>async</code>","text":"<p>List all available resources from the Rhea MCP server.</p> <p>This asynchronous method retrieves a list of all resources accessible through the initialized Rhea client. The client must have an active session before calling this method.</p> <p>Returns:</p> Name Type Description <code>ListResourcesResult</code> <code>list[Resource]</code> <p>A result object containing the list of available resources.</p> <p>Raises:     RuntimeError: If the client session fails to initialize or used outside of a context manager.</p> Source code in <code>client/__init__.py</code> <pre><code>async def list_resources(self) -&gt; list[Resource]:\n    if self._mcp_client is not None:\n        return await self._mcp_client.list_resources()\n    raise RuntimeError(\"`mcp_client` is None\")\n</code></pre>"},{"location":"client/#client.RheaClient.read_resource","title":"<code>read_resource(uri)</code>  <code>async</code>","text":"<p>Read a specific resource from the Rhea MCP server by its URI.</p> <p>This method retrieves the contents of a resource identified by the provided URI. The resource contents can be either text or binary data.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>AnyUrl</code> <p>The URI of the resource to read.</p> required <p>Returns:</p> Type Description <code>list[TextResourceContents | BlobResourceContents]</code> <p>list[TextResourceContents | BlobResourceContents]: A list of resource contents, which can be either text or binary data.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the client session fails to initialize or used outside of a context manager.</p> Source code in <code>client/__init__.py</code> <pre><code>async def read_resource(\n    self, uri: AnyUrl\n) -&gt; list[TextResourceContents | BlobResourceContents]:\n    if self._mcp_client is not None:\n        return await self._mcp_client.read_resource(uri)\n    raise RuntimeError(\"`mcp_clien` is None\")\n</code></pre>"},{"location":"client/#client.RheaClient.upload_file","title":"<code>upload_file(path, name=None, timeout=300, chunk_size=1 &lt;&lt; 20)</code>  <code>async</code>","text":"<p>Upload a file from local directory to Rhea MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path of local file to upload.</p> required <code>name</code> <code>str</code> <p>Optional filename to use on the server side. Defaults to source filename.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Request timeout in seconds. Defaults to <code>300</code> seconds.</p> <code>300</code> <code>chunk_size</code> <code>int</code> <p>Chunk size to read and upload file. Defaults to 1MB.</p> <code>1 &lt;&lt; 20</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Server response</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the client session fails to initialize or used outside of a context manager.</p> Source code in <code>client/__init__.py</code> <pre><code>async def upload_file(\n    self,\n    path: str,\n    name: str | None = None,\n    timeout: int = 300,\n    chunk_size: int = 1 &lt;&lt; 20,\n) -&gt; dict:\n    if self._rest_client is not None:\n        return await self._rest_client.upload_file(path, name, timeout, chunk_size)\n    raise RuntimeError(\"`rest_client` is None\")\n</code></pre>"},{"location":"client/#client.RheaClient.download_file","title":"<code>download_file(key, output_directory=Path.cwd(), timeout=300, chunk_size=1 &lt;&lt; 20)</code>  <code>async</code>","text":"<p>Download a file to local directory from Rhea MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>File key of desired file to download.</p> required <code>output_directory</code> <code>Path</code> <p>Output directory to write to. Defaults to current working directory.</p> <code>cwd()</code> <code>timeout</code> <code>int</code> <p>Request timeout in seconds. Defaults to <code>300</code> seconds.</p> <code>300</code> <code>chunk_size</code> <code>int</code> <p>Chunk size for download stream. Defaults to 1MB.</p> <code>1 &lt;&lt; 20</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Size of downloaded file in bytes.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the client session fails to initialize or used outside of a context manager.</p> Source code in <code>client/__init__.py</code> <pre><code>async def download_file(\n    self,\n    key: str,\n    output_directory: Path = Path.cwd(),\n    timeout: int = 300,\n    chunk_size: int = 1 &lt;&lt; 20,\n) -&gt; int:\n    if self._rest_client is not None:\n        return await self._rest_client.download_file(\n            key, output_directory, timeout, chunk_size\n        )\n    raise RuntimeError(\"`rest_client` is None\")\n</code></pre>"},{"location":"client/#client.RheaClient.metrics","title":"<code>metrics()</code>  <code>async</code>","text":"<p>Get Prometheus metrics from Rhea MCP server.</p> <p>See: Prometheus Specification</p> <p>Returns:</p> Type Description <code>dict[str, list[dict]]</code> <p>dict[str, list[dict]]: Server metrics</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the client session fails to initialize or used outside of a context manager.</p> Source code in <code>client/__init__.py</code> <pre><code>async def metrics(self) -&gt; dict[str, list[dict]]:\n    if self._rest_client is not None:\n        return await self._rest_client.metrics()\n    raise RuntimeError(\"`rest_client` is None\")\n</code></pre>"}]}